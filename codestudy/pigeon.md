# Pigeon - a golang parsing expression grammar(PEG) generator tool

## 1 What's Pigeon

We shoud know PEG first, from Wikipedia [0] :

> A parsing expression grammar is a type of analytic formal grammar, i.e.
> it describes a formal language in terms of a set of rules for recognizing
> strings in the language.

Traditional context-free grammars (CFGs) were often seen in the field of programming languages, but parsing expression grammars (PEGs) are an interesting alternative. 

Pigeon's grammar format see [1].

The advantages using PEGs:

+ PEGs are unambiguous
+ PEGs offer unlimited lookahead
+ No lexer is required, the grammar is "self-contained" 

Ok, Pigeon [2] is a PEG-based parser generator for Go, writen by Martin Angers. There are also other language implements like pegjs.

## 2 Pigeon example

A calculator example: see `pigeon/examples/calculator `

```
// helper function `eval` omitted for brevity
Expr <- _ first:Term rest:(_ AddOp _ Term)* _ {
    return eval(first, rest), nil
}
Term <- first:Factor rest:(_ MulOp _ Factor)* {
    return eval(first, rest), nil
}
Factor <- '(' expr:Expr ')' {
    return expr, nil
} / integer:Integer {
    return integer, nil
}
AddOp <- ('+' / '-') {
    return string(c.text), nil
}
MulOp <- ('*' / '/') {
    return string(c.text), nil
}
Integer <- '-'? [0-9]+ {
    return strconv.Atoi(string(c.text))
}
_ "whitespace" <- [ \n\t\r]*
```

Using pigeon command and up peg file, you can generate a program which can calculate problem like `3*(5+6*2)-45` . Amazing! No lexer code was writen and no yacc was needed. 

## 3 Pigeon code internals

The pigeon command-line tool is itself a parser generated by pigean. The initial issue of generating the first parser generator is called bootstrapping and is a common concept in compilers. Pigeon's author uses a traditional hand-written lexer and recursive top-down parser to bootstrap pigeon called bootstrap-pigeon. Then bootstrap-pigeon is able to parse the full grammer, and the final, offical pigeon tool is built this way.

As a generator, pigeon's code can be devided into three parts:

+ pigeon/ast
+ pigeon/builder
+ pigeon/parser

Ast defines PEG grammer, builder outputs generated-parser code.  

The initial hand-writen bootstrap-pigeon parser code is as follows:

+ bootstrap/token.go
+ bootstrap/scan.go
+ bootstrap/parser.go

Golang is utf-8 compatible, and the hard point when implementing pigeon scan is handling string's char-escape issues, such as  quotation marks, unicode classes.

Pigeon's golang code was well documented and well tested.  Writing godoc friendly codes and full-cover unittests is a base capability for gopher.

## 4 Summary 

Why should we using a parser to solve problems?  In fact, the application programs we writen contain two categeries: technical codes and business logic codes. Business logic codes can be hard-code or using a DSL. When writing business logics, we don't want mention Buffer, byte, file io, network send recv and other issues, we just want an abstract level programming feeling. 

For example, request fields validation in web programming is a DSL problem. We don't like writing so much validation codes again and again before handling any request struct. However we use a declative method to indicate request validation rules(like 'required', 'maxlen:10','format:email') and using a validation engine(using reflect tech.) to handle it. 

Parsing expression grammar parser generator is a good common-use DSL solution:

+ Design a high level complex business DSL format, not limited in programming language format
+ Quickly implement your DSL parser and evaluator, you just write a peg rule file and handle code
+ Define a DSL AST and implement a custom builder, you can quickly implement your own generator

## 5 Reference

[0]: http://en.wikipedia.org/wiki/Parsing_expression_grammar
[1]: https://godoc.org/github.com/mna/pigeon
[2]: https://github.com/mna/pigeon